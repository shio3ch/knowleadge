# Effective Java （第3版）

## 第2章 オブジェクトの生成と消滅

* [項目1 コンストラクタの代わりにstaticファクトリメソッドを検討する](./01.md)
* [項目2 多くのコンストラクタパラメータに直面した場合はビルダーを検討する](./02.md)
* [項目3 privateのコンストラクタかenum型でシングルトン特性を強制する](./03.md)
* [項目4 privateのコンストラクタでインスタンス化不可能を強制する](./04.md)
* [項目5 資源を直接結び付けるよりも依存性注入を選ぶ](./05.md)
* [項目6 不必要なオブジェクトの生成を避ける](./06.md)
* [項目7 使われなくなったオブジェクト参照を取り除く](./07.md)
* [項目8 ファイナライザとクリーナーを避ける](./08.md)
* [項目9 try-finallyよりもtry-with-resourcesを選ぶ](./09.md)

## 第3章 すべてのオブジェクトに共通のメソッド

* [項目10 equalsをオーバーライドするときは一般契約に従う](./10.md)
* [項目11 equalsをオーバーライドするときは、常にhashCodeをオーバーライドする](./11.md)
* [項目12 toStringを常にオーバーライドする](./12.md)
* [項目13 cloneを注意してオーバーライドする](./13.md)
* [項目14 Comparableの実装を検討する](./14.md)

## 第4章 クラスとインタフェース

* [項目15 クラスとメンバーへのアクセス可能性を最小限にする](./15.md)
* [項目16 publicのクラスでは、publicフィールドではなくアクセッサーメソッドを使う](./16.md)
* [項目17 可変性を最小限にする](./17.md)
* [項目18 継承よりもコンポジションを選ぶ](./18.md)
* [項目19 継承のために設計および文書化する、でなければ継承を禁止する](./19.md)
* [項目20 抽象クラスよりもインタフェースを選ぶ](./20.md)
* [項目21 将来のためにインタフェースを設計する](./21.md)
* [項目22 型を定義するためだけにインタフェースを使う](./22.md)
* [項目23 タグ付きクラスよりもクラス階層を選ぶ](./23.md)
* [項目24 非staticのメンバークラスよりもstaticのメンバークラスを選ぶ](./24.md)
* [項目25 ソースファイルを単一のトップレベルのクラスに限定する](./25.md)

## 第5章 ジェネリックス

* [項目26 原型を使わない](./26.md)
* [項目27 無検査警告を取り除く](./27.md)
* [項目28 配列よりもリストを選ぶ](./28.md)
* [項目29 ジェネリック型を使う](./29.md)
* [項目30 ジェネリックメソッドを使う](./30.md)
* [項目31 APIの柔軟性向上のために境界ワイルドカードを使う](./31.md)
* [項目32 ジェネリックスと可変長引数を注意して組み合わせる](./32.md)
* [項目33 型安全な異種コンテナを検討する](./33.md)

## 第6章 enumとアノテーション

* [項目34 int定数の代わりにenumを使う](./34.md)
* [項目35 序数の代わりにインスタンスフィールドを使う](./35.md)
* [項目36 ビットフィールドの代わりにEnumSetを使う](./36.md)
* [項目37 序数インデックスの代わりにEnumMapを使う](./37.md)
* [項目38 拡張可能なenumをインタフェースで模倣する](./38.md)
* [項目39 命名パターンよりもアノテーショんを選ぶ](./39.md)
* [項目40 常にOverrideアノテーションを使う](./40.md)
* [項目41 型を定義するためにマーカーインタフェースを使う](./41.md)

## 第7章 ラムダとストリーム

* [項目42 無名クラスよりもラムダを選ぶ](./42.md)
* [項目43 ラムダよりもメソッド参照を選ぶ](./43.md)
* [項目44 標準の関数型インタフェースを使う](./44.md)
* [項目45 ストリームを注意して使う](./45.md)
* [項目46 ストリームで副作用のない関数を選ぶ](./46.md)
* [項目47 戻り値型としてStreamよりもCollectionを選ぶ](./47.md)
* [項目48 ストリームを並列化するときは注意を払う](./48.md)

## 第8章 メソッド

* [項目49 パラメータの正当性を検査する](./49.md)
* [項目50 必要な場合、防御的にコピーする](./50.md)
* [項目51 メソッドのシグニチャを注意深く設計する](./51.md)
* [項目52 オーバーロードを注意して使う](./52.md)
* [項目53 可変長引数を注意して使う](./53.md)
* [項目54 nullではなく、空コレクションか空配列を返す](./54.md)
* [項目55 オプショナルを注意して返す](./55.md)
* [項目56 すべての公開API要素に対してドキュメントコメントを書く](./56.md)

## 第9章 プログラミング一般

* [項目57 ローカル変数のスコープを最小限にする](./57.md)
* [項目58 従来のforループよりもfor-eachループを選ぶ](./58.md)
* [項目59 ライブラリを知り、ライブラリを使う](./59.md)
* [項目60 正確な答えが必要ならば、floatとdoubleを避ける](./60.md)
* [項目61 ボクシングされた基本データよりも基本データ型を選ぶ](./61.md)
* [項目62 他の型が適切な場所では、文字列を避ける](./62.md)
* [項目63 文字列結合のパフォーマンスに用心する](./63.md)
* [項目64 インタフェースでオブジェクトを参照する](./64.md)
* [項目65 リフレクションよりもインタフェースを選ぶ](./65.md)
* [項目66 ネイティブメソッドを注意して使う](./66.md)
* [項目67 注意して最適化する](./67.md)
* [項目68 一般的に受け入れられている命名規則を守る](./68.md)

## 第10章 例外

* [項目69 例外的状態にだけ例外を使う](./69.md)
* [項目70 回復可能な状態にはチェックされる例外を、プログラミングエラーには実行時例外を使う](./70.md)
* [項目71 チェックされる例外を不必要に使うのを避ける](./71.md)
* [項目72 標準的な例外を使う](./72.md)
* [項目73 抽象概念に適した例外をスローする](./73.md)
* [項目74 各メソッドがスローするすべての例外を文書化する](./74.md)
* [項目75 詳細メッセージにエラー記録情報を含める](./75.md)
* [項目76 エラーアトミック性に努める](./76.md)
* [項目77 例外を無視しない](./77.md)

## 第11章 並行性

* [項目78 共有された可変データへのアクセスを同期する](./78.md)
* [項目79 過剰な同期は避ける](./79.md)
* [項目80 スレッドよりもエグゼキュータ、タスク、ストリームを選ぶ](./80.md)
* [項目81 waitとnotifyよりも並行処理ユーティリティを選ぶ](./81.md)
* [項目82 スレッド安全性を文書化する](./82.md)
* [項目83 遅延初期化を注意して使う](./83.md)
* [項目84 スレッドスケジューラに依存しない](./84.md)

## 第12章 シリアライズ

* [項目85 Javaのシリアライズよりも代替手段を選ぶ](./85.md)
* [項目86 Serializableを細心の注意を払って実装する](./86.md)
* [項目87 カスタムシリアライズ形式の使用を検討する](./87.md)
* [項目88 防御的にreadObjectメソッドを書く](./88.md)
* [項目89 インスタンス制御に対しては、readResolveよりもenum型を選ぶ](./89.md)
* [項目90 シリアライズされたインスタンスの代わりに、シリアライズ・プロキシを検討する](./90.md)
