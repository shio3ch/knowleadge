# 原型を使わない

## ジェネリクスの仕様

* 仮型パラメータ
  * クラス名、インタフェース名の後ろにアングルブラケット`<>`で囲んだもの
  * 慣例的に`<E>`や`<T>`などの1文字で表される
    （`E`は`Element`の略で、`T`は`Type`の略だったりする）
  * 仮型パラメータはコンパイルのための情報であり、実行時には削除される
    * `new T()`だったり、`T.class`のような、実行コードは定義出来ない
  * 複数の仮型パラメータを定義することも出来る
    * 例）`Map<K, V>`
* 実型パラメータ
  * 仮型パラメータに型情報が渡された際の呼び方
  * 例えば、`List<E>`が仮型パラメータなのに対して、`List<String>`は実型パラメータ

## 原型

* `List<E>`というジェネリック型であれば、`List`が原型となる
* 原型であっても、ふるまい的には`List<E>`と変わらない
* 原型を使うと、ジェネリックの安全性と表現力をすべて失う
  * 原型の`List`で考えると、要素の取り出し時でキャストする際に型が正しいという保証がない
    （`List`のコレクションの実態は`Object[]`である）
  * ジェネリック型は、実型パラメータで宣言された型がキャストされることが保証されている
  * `ClassCastException`を防ぐ観点で、まず原型を使うことはない
    あくまで、互換性のために残っている古いものだと認識する

## 非境界ワイルドーカード型を使う

* `Set<?>`のようなもの
* ジェネリック型を使いたいが、実際の型パラメータが何であるか分からない、あるいは気にしない場合に使う
* 

## instanceof演算子を使うのが望ましい場面

* ジェネリック型の情報は実行時に消える
* 非境界ワイルドカード型以外のパラメータ化された型に対する`instanceof`演算子は使えない
* 

## 重要な考え方

* エラーは早い段階、それもコンパイル時に取り除けることが理想
  * この観点で考えると、出来る限りジェネリクスを使うべき
  * 原型を使うと実行時まで見つけられない上に、どこで注入されたのか探すのも困難になる
