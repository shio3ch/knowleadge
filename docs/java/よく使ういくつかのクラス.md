# よく使ういくつかの類似のクラス

## コレクション（Collection）

### Iterable<T>

* 要素セットの反復（繰り返し）が可能であることを示すインタフェース
* このインタフェースを実装すると、 foreach 文の対象にすることが出来る

### Collection<E>

* コレクション階層のルートインタフェース
* コレクションとは、その「要素`<E>`」であるオブジェクトのグループであることを示す
* Iterableを継承する

### Map

* キーに対して1つの値（オブジェクト）を保持するインタフェース
* Map 自体は Collection を継承しているわけではなく、要素を Collection で管理する
  * 当然ながら、 foreach 文に Map 自体を使うことは出来ない
  * `keySet()`メソッドで Collection を使う

#### HashMap

* キーからハッシュ値を算出して管理する
* 順序は不定となる

#### TreeMap

* キーの自然順序付けによってソートされる

#### LinkedHashMap

* HashMap と LinkedList の両方で管理する
* 挿入された順を保持する
* LinkedHashMapを継承して、`removeEldestEntry`メソッドをオーバーライドすることで、put時に最も古い要素を削除する条件を設けることが出来る
  * 一番分かりやすい使い方は、要素数に上限を設けること
  * HashMapでは`return false;`となっており、古い要素を削除することはない
* LinkedHashMapのコンストラクタで`accessOrder`をtrueとすると、`get`の度、要素が後ろに移動する
* `removeEldestEntry`と`accessOrder`を使用して、LRU（Least Recently Used）キャッシュが実現出来る

### Set

* キーやインデックスとは関連付けず、一意の値を保持するインタフェース
* nullを許容するかどうかは、実装に依存する
* 値が同じかどうかは、`equals`メソッドか、`hashCode`メソッドで判断する
* Listと比較して、重複のないオブジェクトを使用し、要素の順序を意識しないのであればこちらを使うのが望ましい
  * 実装例でいうと、キーとなるIDの比較に用いる
  * containsの処理時間が圧倒的に早い

#### HashSet

* 順序は不定

#### LinkedHashSet

* 要素の挿入順を保持する

#### EnumSet

* 列挙型と一緒に使用するための Set 実装
* null要素は許可しないので、null要素を挿入しようとするとぬるぽが起きる
* 内部的にはビット・ベクトルとして表現するので、高速で探索が行われる

### List

* 順序付けられたコレクション（シーケンスともいう）
* インデックスを使用して参照出来ることを保証するので、リスト内のどこに要素が挿入されるか精密に制御出来る
* ListIteratorという特殊なイテレータを提供する
  * リスト内の指定した位置から開始するイテレータ
* ほとんどの実装で、contains、containsAllは線形探索なので、要素数が多いと一気にパフォーマンスが下がる

#### 
